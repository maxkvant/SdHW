## Roguelike

##### Общие сведения о системе

Roguelike -- игра с консольной графикой, управлением с клавиатуры.

Компоненты игры:

* Подземелье: лабиринт с комнатами, стенами, тропинками между комнатами

* Мобы: способные действовать (перемещаться/атаковать) противника персонажи.
Мобы могут атаковать только других мобов, находящихся в соседней клетке; могут перемещаться только в соседнюю, незанятую клетку.

Может выбрать 1 артефакт из своего хранилища артефактов. В таком случае, на моба действует эффект выбранного артефакта.

Может удалять артефакты из своего хранилища

Один mob управляется игроком. Остальные мобы -- враги, каждый из них управляться рандомизированным алгоритмом.

* Обычный Бой:

Пусть **mob** атакует **victim**, тогда hp **victim** уменьшается на max(0, **mob.attack** - **victim.defence**)

Если **victim** погибает после атаки, **mob** забирает артефакты у **victim** и пытается ими дозаполнить своё хранилище.

* Артефакты

  * Knife -- увеличение attack моба

  * Helmet -- увеличение defence моба

  * Freezer -- действие обычного удара с некоторой вероятностью заменяется на обездвиживание противника на несколько ходов.

### Управление
* перемещение -- стрелками (если хотим переместиться в моба, то атакуем его)
* enter -- пропустить ход
* сменить/выбрать артефакт -- нажать соотв. цифру (например, выбрать второй артефакт, нажать 2)
* del -- удалить выбранный артефакт
* q -- выход
* r -- начать заново

#### Architectural drivers

* выбрана платформа jvm, т.к. хочется, чтобы игра была кроссплатформенной

альтернатива .net подходит меньше из-за отсутствия опыта использования

* язык kotlin

альтернативы: java, scala

* мобы противника сами (вызовом метода turn) определяют что им делать. Так сделано, чтобы разработчик старался сделать мобов "честными".

* эффект добавляется с помощью шаблона декоратор, предполагается, что так можно реализовать очень широкий набор эффектов

* выбрана генерация карты с использованием сторонней библиотеки

альтернативы:

  * загрузка карты из файла -- не похоже на канонический рогалик

  * генерация своим алгоритмом

##### Роли и случаи использования

В игре есть 1 роль игрок. Использовать можно, чтобы занять своё время игрой.

Типичный пользователь: игрок которому нравится играть в простенькие рогалики, не далеко ушедшие от оригинального rogue.

###### Варианты целей

* Убить всех врагов

* Погибнуть за наименьшее / наибольшее число шагов

* Исследовать всё поле

* Попробовать все артефакты

* ...



#### Диаграмма компонентов

* Model -- состояние игры

* View -- визуализация / получение действий пользователя

* Controller -- выполняет действия пользователя

* MobCore -- примитивы для реализации мобов

* Actions -- действия, которые моб может попросить выполнить

* Artifacts -- хранилища артефактов

* Effects -- эффекты, с помощью которых можно изменить характеристики моба



#### Диаграмма классов

##### Компонента mob

`MobWithEffects`  -- интерфейс моба, используемого в модели игры.
Чтобы создать объект такого типа, можно отнаследоваться от  `MobDecoratorCombiner` . Также, чтобы выбранный артефакт из storage работал, надо добавить эффект  `StorageEffect()`  этому мобу.

`MobFactory`  -- фабрика мобов: с помощью неё можно создавать "готовых" мобов.

`PlayerMobWithEffects`  -- интерфейс моба игрока: ему можно указать, что делать на следующем ходу.

Action  -- интерфейс для действия, которое моб просит сделать.
  *  `Rest()`  -- ничего не делать
  *  `Move(posTo)`  -- переместиться в posTo
  *  `HitAction(victim)`  -- интерфес для действия атаки на `victim`

    *  `HitSibling(victim)`  -- атаковать victim обычным ударом

    *  `FreezeSibling(victim)`  -- попытаться заморозить `victim` на несколько шагов

`Effect`  -- интерфейс для эффекта. Чтобы создать какой-нибудь эффект можно отнаследоваться от `EffectImpl` .

`Artifact`  -- класс для артефакта

`ArtifactsStorage`  -- интерфейс для хранилища артефактов моба.

##### Компонента Model

`Model`  -- Интерфес для модели игры.
Можно добавлять мобов или удалять оттуда. Обновлять позиции мобов после их перемещения.
Также можно получить моба игрока, число совершённых ходов, узнать, что находится в такой-то клетке поля.

`generateField(n,m)`  -- функция генерации игрого поля в виде подземелья.

`generateMobs(field, density)`  -- функция генерации мобов на игровом поле [field] с долей места занимаемого мобами [density].

`ModlelImpl`  -- реализация интерфейса model.

`FieldReadOnly`  -- интерфейс для поля n x m.

`Cell`  -- клетка поля игрового поля. бывает трёх видов: стена, свободное пространство, дорожка в между комнатами.

##### Компонента Controller

`GameController`  -- управляет процессом игры, реагируя на события из `GameView`.

`SubController`  -- интерфейс обработчика событий игры.

`AtifactsController`  -- обработчика событий выбора/удаления.

`MobsController`  -- обработка перемещений/ударов игрока, ходов других мобов.

##### Компонента View

`GameView`  -- управляет процессом игры, реагируя на события из `GameView`.

`GameViewImpl`  -- реализация  `GameView`  с помощью библиотеки  `zircon` .

`TerminalLayer`  -- интерфейс отображения чего-нибудь в прямоугольной части терминала.

`InfoLayer`  -- отображение общей информации об игре: hp игрока, число ходов...

`ArtefactsLayer`  -- отображение артефактов игрока, выбранного артефакта.

`FieldLayer`  -- отображение части игрового поля рядом с игроком.

<img src="diagrams/roguelike-architecture.png" />

#### Взаимодействия и Состояния

##### Диаграмма последовательностей

Описывает происходящее в `GameController` после действия пользователя. 

<img src="diagrams/roguelike-sequence.png" />

##### Диаграммы состояния

###### Диаграмма состояния GameController

<img src="diagrams/roguelike-controller-state.png" />

#### Зависимости

`czyzby:noise4j`  -- генерация карты

`zircon`  -- для рисования терминала, получения действий пользователя

`junit`,  `hamcrest`  -- для юнит-тестов

`kotlin-logging`  -- логирование
